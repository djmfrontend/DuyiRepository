## 大文件上传

### 背景

大数据包,视频的大文件的上传,如果不做特殊处理，将遇到一下问题

1. 网络中断、程序异常退出等问题导致文件上传失败，从而不得不全部重新上传
2. 同一文件被不同用户反复上传，白白占用网络和服务器存储资源

因此，需要一个针对大文件上传的方案解决上述问题

### 问题和方案

大文件上传的普遍方案是文件分片上传

如果把文件上传看做是一个不可分割的事务，那么分片的目标就是把一个耗时的大事务划分为一个一个的小事务,

由于公司使用BFF层来承接前端的文件请求，因此需要打通前后端所有跟文件上传的障碍

BFF 层 相当于中间服务器 

![image-20240417103552031](/Users/teiyoshiaki/Library/Application Support/typora-user-images/image-20240417103552031.png)

分片上传的主要障碍集中在

1. 如何减少页面阻塞
2. 前后端如何协调
3. 代码如何组织
4. 前端代码中的复杂逻辑
5. BFF代码中的复杂逻辑

下面分开阐述

#### 如何减少页面阻塞

分片上传的一个首要目标就是尽量避免相同的分片重复上传。服务器必须要能够识别来自各个客户端的各个上传请求中，是否存在与过去相同的上传请求。

![image-20240417105414563](/Users/teiyoshiaki/Library/Application Support/typora-user-images/image-20240417105414563.png)

服务器如何识别那些分片是相同的呢?

首先需要对相同下一个准确的定义,文件内容一样即为相同

可是对文件内容进行二进制的对比是一个非常耗时的操作,于是可以选择基于内容的hash来进行对比。

文件内容— hash

>Hash 是一种算法 可以将任何长度的数据转为定长的数据
>
>这里使用 MD5进行hash计算 使用第三方库 Spark-MD5

![image-20240417163210130](/Users/teiyoshiaki/Library/Application Support/typora-user-images/image-20240417163210130.png)



不仅针对分片如此,针对整个文件也是如此

可见，客户端需要承担两件重要的事情

1. 对文件进行切片，计算每个分片的hash值
2. 根据所有分片的hash值，计算整个文件的hash值

而计算hash值是一件CPU密集型的操作，如果不加处理将会导致长时间阻塞主线程

![image-20240417170447030](/Users/teiyoshiaki/Library/Application Support/typora-user-images/image-20240417170447030.png)

为了解决这个问题，我们可以对大文件上传做一个大胆的假设：绝大部分的文件上传都是新文件上传。

有了这个假设，我们就无需等待整体hash的计算结果，直接上传分片即可，同时可以把分片操作使用多线程+异步的方式进行上传处理



![image-20240417171131911](/Users/teiyoshiaki/Library/Application Support/typora-user-images/image-20240417171131911.png)



这样做的好处是，页面完全无阻塞，也无需等待整体hash即可启动上传，相比于传统方案

1. 对于新文件上传可以缩短整体上传时间，消除页面阻塞
2. 对于旧文件上传可能会产生一些无效的请求，但这些请求仅传递的是hash值，并不真实上传文件数据，所以对网络和服务器的影响很小，加之旧文件上传的情况很少，所以整体影响不大

#### 前后端如何协调

文件上传涉及到前后端的交互，需要建立一个标准的通信协议，通过协议要能完成下面几件核心交互

1. 创建文件
2. hash校验
3. 分片数据上传
4. 分片合并

##### 创建文件协议

当客户端发送分片到服务器时，需要告知服务器分片属于哪一次文件上传，因此需要一个唯一标识来识别某一次文件上传。

创建文件协议就是用于获取文件上传的唯一标识

##### hash文件协议

